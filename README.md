DesignPattern
=============

设计模式DEMO
说明：com.luulsj.www.designpattern.pattern1为设计模式的实现代码
           com.luulsj.www.designpattern.pattern1.test为对应的设计模式的测试类
=============
何为设计模式？
  每一个模式描述了一个在我们周围不断发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次的使用该方案而不必做重复的劳动。
  描述为：在一定环境中解决某一问题的方案，包括三个基本元素----问题，解决方案和环境。

模式分为三种类型：
  创建模式：可以简单的理解为，使创建对象的方式看起来更牛逼，更高大上的模式。

=============
1.2014年11月10日12:07:33
单例设计模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。
参考wiki:http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F

2.2014年11月11日14:38:56
简单工厂模式
简单工厂模式的实质是由一个工厂类根据传入的参数，动态的决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。
参考wiki:http://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#.E7.AE.80.E5.8D.95.E5.B7.A5.E5.8E.82
用来处理在不指定对象具体类型的情况下创建对象的问题。
角色：
	工厂角色（Creator）：核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
	抽象产品角色（Product）：Creator创建的所有对象的父类，它负责描述所有实例所共有的特性。
	具体产品角色（Concrete Product）：Creator的创建目标。
note:由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

3.2014年11月12日15:46:05
工厂方法
工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到了子类中进行”
核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得
工厂方法模式可以在不修改具体工厂角色的情况下引进新的产品。
角色：
	抽象工厂Creator：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
	具体工厂Concrete Creator：是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。
	抽象产品角色Product：工厂方法模式所创建对象的超类型。
	具体产品角色Concrete Creator：这个角色实现了抽象产品角色所定义的接口。
故事理解：
	从前，有一个村，他们有一块很大的土地，属于村民所有。一天呀，勤劳务实的村长要创建一个水果公司，
这个想法得到了全体村民的支持，大家都拭目以待。
	各种工作蓄势以待，首先村长引入了苹果这种水果，然后吩咐张三家专门种苹果。
	接着，引入了香蕉，然后吩咐李四家专门种香蕉。
	接着，梨子，王五家专门种梨子。
	... ...
	
	从此以后，家家户户都可以吃各种各样的水果了，想吃什么水果了，只要去专门种植这种水果的人家去摘就好了。
	真实一副欣欣向荣，千帆竞发的景象呀。

4.2014年11月13日16:37:40
策略模式(Strategy)：定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立
于使用它的客户而独立变化。
角色：
	抽象策略角色：策略类，通常由一个接口或者抽象类实现。
	具体策略角色：包装了相关的算法和行为。
	环境角色：持有一个策略类的引用，最终给客户端调用。
		使用具体策略类提供的算法；内部维护一个策略类实例；负责动态设置运行时Strategy具体的实现算法；负责跟Strategy之间的交互和数据传递。
参考：http://baike.baidu.com/view/2141079.htm?fr=aladdin
这一篇文章写的很好，需要反复的理解，加深印象：http://blog.csdn.net/hguisu/article/details/7558249

2014年11月20日10:54:05
状态模式 State
1.在软件开发过程中，应用程序可能会根据不同的情况作出不同处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到。
然后使用if... ellse语句来做状态判断来进行不同情况的处理。但是对复杂状态的判断就显得“力不从心了”。
随着增加新的状态或者修改一个状体（if else(或switch case)语句的增多或者修改）可能会引起很大的修改，而程序的可读性，扩展性也会变得很弱。
维护也会很麻烦。那么我就考虑只修改自身状态的模式。

2.问题：对象如何在每一种状态下表现出不同的行为？

3.解决方案：状态模式，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的对象（stateful),这样的对象状态
是从事先定义好的值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。

4.适用性
在下面的两种状态下，均可使用状态模式
1）一个对线的行为取决于他的状态，并且它必须在运行时刻根据状态改变它的行为。
2）代码中包含大量与对象状态有关的条件语句，一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式，将每一个条件分支放入一个独立的类中，这使得你可以
根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

5.模式的组成
环境类（Context）：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义当前状态。
抽象状态类（State）：封装了与Context的一个特定状态相关的行为。
具体状态类（ConcreteState）：每一子类实现一个与Context的一个状态相关的行为。
这个模式，对我而言，不好理解。