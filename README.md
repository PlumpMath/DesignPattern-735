DesignPattern
=============

设计模式DEMO
说明：com.luulsj.www.designpattern.pattern1为设计模式的实现代码
           com.luulsj.www.designpattern.pattern1.test为对应的设计模式的测试类
=============
何为设计模式？
  每一个模式描述了一个在我们周围不断发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次的使用该方案而不必做重复的劳动。
  描述为：在一定环境中解决某一问题的方案，包括三个基本元素----问题，解决方案和环境。

模式分为三种类型：
  创建模式：可以简单的理解为，使创建对象的方式看起来更牛逼，更高大上的模式。

=============
1.2014年11月10日12:07:33
单例设计模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。
参考wiki:http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F

2.2014年11月11日14:38:56
简单工厂模式
简单工厂模式的实质是由一个工厂类根据传入的参数，动态的决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。
参考wiki:http://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#.E7.AE.80.E5.8D.95.E5.B7.A5.E5.8E.82
用来处理在不指定对象具体类型的情况下创建对象的问题。
角色：
	工厂角色（Creator）：核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
	抽象产品角色（Product）：Creator创建的所有对象的父类，它负责描述所有实例所共有的特性。
	具体产品角色（Concrete Product）：Creator的创建目标。
note:由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

3.2014年11月12日15:46:05
工厂方法
工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到了子类中进行”
核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得
工厂方法模式可以在不修改具体工厂角色的情况下引进新的产品。
角色：
	抽象工厂Creator：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
	具体工厂Concrete Creator：是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。
	抽象产品角色Product：工厂方法模式所创建对象的超类型。
	具体产品角色Concrete Creator：这个角色实现了抽象产品角色所定义的接口。
故事理解：
	从前，有一个村，他们有一块很大的土地，属于村民所有。一天呀，勤劳务实的村长要创建一个水果公司，
这个想法得到了全体村民的支持，大家都拭目以待。
	各种工作蓄势以待，首先村长引入了苹果这种水果，然后吩咐张三家专门种苹果。
	接着，引入了香蕉，然后吩咐李四家专门种香蕉。
	接着，梨子，王五家专门种梨子。
	... ...
	
	从此以后，家家户户都可以吃各种各样的水果了，想吃什么水果了，只要去专门种植这种水果的人家去摘就好了。
	真实一副欣欣向荣，千帆竞发的景象呀。

4.2014年11月13日16:37:40
策略模式(Strategy)：定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立
于使用它的客户而独立变化。
角色：
	抽象策略角色：策略类，通常由一个接口或者抽象类实现。
	具体策略角色：包装了相关的算法和行为。
	环境角色：持有一个策略类的引用，最终给客户端调用。
		使用具体策略类提供的算法；内部维护一个策略类实例；负责动态设置运行时Strategy具体的实现算法；负责跟Strategy之间的交互和数据传递。
参考：http://baike.baidu.com/view/2141079.htm?fr=aladdin
这一篇文章写的很好，需要反复的理解，加深印象：http://blog.csdn.net/hguisu/article/details/7558249

2014年11月20日10:54:05
状态模式 State
1.在软件开发过程中，应用程序可能会根据不同的情况作出不同处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到。
然后使用if... ellse语句来做状态判断来进行不同情况的处理。但是对复杂状态的判断就显得“力不从心了”。
随着增加新的状态或者修改一个状体（if else(或switch case)语句的增多或者修改）可能会引起很大的修改，而程序的可读性，扩展性也会变得很弱。
维护也会很麻烦。那么我就考虑只修改自身状态的模式。

2.问题：对象如何在每一种状态下表现出不同的行为？

3.解决方案：状态模式，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的对象（stateful),这样的对象状态
是从事先定义好的值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。

4.适用性
在下面的两种状态下，均可使用状态模式
1）一个对线的行为取决于他的状态，并且它必须在运行时刻根据状态改变它的行为。
2）代码中包含大量与对象状态有关的条件语句，一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式，将每一个条件分支放入一个独立的类中，这使得你可以
根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

5.模式的组成
环境类（Context）：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义当前状态。
抽象状态类（State）：封装了与Context的一个特定状态相关的行为。
具体状态类（ConcreteState）：每一子类实现一个与Context的一个状态相关的行为。
这个模式，对我而言，不好理解。

2014年12月23日16:35:37
模板方法模式Template Method
概述：
在面向对象开发过程中，通常我们会遇到这样的一个问题：我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序。但是某些步骤的具体实现是未知的，或者说
某些步骤的实现与具体环境相关。

问题：
如何保证架构逻辑的正常执行，而不被子类破坏？

解决方案：
模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。T模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
在模板方法模式中，我们需要准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来让子类实现剩余的逻辑。
不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，这就是模板方法模式的用意。
模板方法模式体现了面向对象的诸多重要思想，是一种使用频率较高的模式。

适用性：
一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

组成：抽象类、具体子类

优点：
模板方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。